#' Abundance profiles
#'
#' Calculates species' abundances through time for a simulation.
#'
#' The function calculates species' abundances over a window of time 
#' given in \code{t_window}. This can be either a continuous set of timepoints
#' (designated by passing a list with elements \code{start} and \code{stop})
#' or an explicit set of timepoints (passed as a vector of integers). 
#' Timepoints correspond to actual timesteps in the simulation, even if
#' not all timesteps are saved in \code{sim}. Specifying \code{start=1}
#' will return the first timestep, not the first step saved in \code{sim}.
#' If the simulation did not save the the first timestep then the function
#' will exit with an error message.
#'
#' Species abundances are summed over the set of cell locations given in 
#' \code{locs}. If \code{locs} is a list (as generated by 
#' \code{\link{aggregate_cells}}) then each element of the list specifies a 
#' matrix of cells (a 'spatial unit') in which abundance should be summed. 
#' For example, to calculate species' abundances in each cell separately, 
#' pass a list where each element is the coordinates of a single cell. 
#' The function returns an array of species' abundances with dimensions:
#' \code{[timepoint, species, spatial unit]}. It will include a column labeled
#' \code{'0'} for the number of empty spaces.
#'
#' @param locs (required) either a two-column matrix of cell locations where 
#' 	species' abundances should be summed or a list of matrices designating
#' 	multiple spatial units where abundance should be summed (see details)
#' @param t_window (required) either a list containing \code{start}
#' 	and \code{stop} specifying that all collected timepoints in that interval
#' 	should be considered or an explicit vector of timepoints 
#' @param sim (required) array of simulation results from a single 
#' 	simulation run (as returned by \code{\link{run_sim}})
#' @param N_S (required) number of species in the simulation
#' @return an array of species' abundances with dimensions:
#' 	\code{[timepoint, species, spatial unit]}
#'
#' @export

calc_abun_profile = function(locs, t_window, sim, N_S){
	
	# Determine which timepoints to evaluate
	timepoints = as.numeric(dimnames(sim)$time)
	if(is.list(t_window)){
		use_times = timepoints[timepoints >= t_window$start & timepoints <= t_window$stop]
	} else {
		# Catch error when a time is specified that was not recorded in simulation
		if(sum(t_window %in% timepoints) < length(t_window)){
			missing = t_window[!(t_window %in% timepoints)]
			stop(paste('Trying to measure occurance during timepoints not recorded in simulation. T =', paste(missing, collapse=' ')))
		}

		use_times = t_window
	}
	
	# Stop if no times
	if(length(use_times)==0) stop('Cannot calculate abundance on 0 timepoints. Check that t_window is in sim.')

	# Determine whether cells should be aggregated
	if(!is.list(locs)) locs = list(locs)
	
	# For each location:
	abun_profiles = sapply(locs, function(cell_block){
	
		# For each block of cells to be aggregated
		each_cell = sapply(1:nrow(cell_block), function(i){
			
			# Convert community profile to matrix
			x = as.numeric(cell_block[i,])
			comm_mat = simplify2array(sim[x[1],x[2],as.character(use_times)])

			# Calculate abundance of each species across timesteps
			abuns = sapply(0:N_S, function(sp) colSums(comm_mat==sp))
			if(is.vector(abuns)) abuns = add_dim(abuns,1); rownames(abuns) = as.character(use_times)
			colnames(abuns) = 0:N_S

			# Return abundances
			abuns
		}, simplify='array')

		# Sum cells across species and timepoints
		apply(each_cell, 1:2, sum)
		# dims are now [timepoints, species]
		
	}, simplify='array')

	# Return abundance profiles
	abun_profiles
}
