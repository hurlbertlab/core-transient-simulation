#' Create a metacommunity
#'
#' Creates a community for each cell on a landscape by defining the number  
#' of individuals each cell can hold (carrying capacity) and
#' distributing individuals from a species pool into those communities
#' according to a global species abundance distribution (gsad).
#'
#' The function returns a metacommunity on which a simulation can be conducted.
#' A metacommunity is a matrix of lists whose dimensions match the landscape
#' specified by \code{land}. Each list corresponds to a cell and contains a 
#' single vector of integers indicating which species are currently 
#' established in the cell. 
#' 
#' Individuals are distributed across the landscape in two steps.
#' First, the function determines a carrying capacity for each cell using
#' the parameter \code{K}, which can be either a single number, for the same
#' number of individuals in each cell, or a matrix whose dimensions match the
#' landscape giving a different number of individuals in each cell.
#' The spatial distribution of individuals is then defined by the 
#' \code{distribution} parameter which can have the following values:
#'	\describe{
#'		\item{\code{'same'}}{all cells are filled to the same proportion 
#' 			(\code{p}) of their carrying capacity.}
#'		\item{\code{'uniform'}}{individuals are randomly placed in cells such
#'			such that the total carrying capacity of the landscape is filled
#'			to proportion \code{p}}
#'		\item{\code{'designated'}}{user specifies which cells should receive 
#'			individuals and (optionally) how many individuals each cell should
#'			receive using the \code{which_cells} parameters. If 
#'			is only specified with two columns (for the cell locations)
#' 			then each cell is filled to proportion \code{p}.}
#'	}
#' Species are chosen at random according to their relative abundance, 
#' as specified by \code{gsad}.
#' 
#' @param land (required) matrix or raster of habitat types defining
#' 	the landscape (as generated by \code{\link{make_landscape}})
#' @param species (required) array of species vital rates (as generated by
#' 	\code{\link{make_species}})
#' @param gsad vector defining the global relative abundance of each species.
#' 	Must be in the same order as \code{species}. Defaults to same abundance 
#'	for all species.
#' @param K (required) a single number defining a carrying capacity for all cells
#' 	 or a matrix of carrying capacities for each landscape cell. Must match
#' 	dimension of \code{land}.
#' @param distribution character describing how individuals should be 
#' 	disributed across the landscape (see details). Defaults to \code{'same'}  
#' 	unless \code{which_cells} is specified.
#' @param p proportion of carrying capacity to be filled. Defaults to 1 = full.
#' @param which_cells two column matrix indicated the x and y coordinates of 
#' 	cells to receive individuals. May optionally contain a 3rd column 
#' 	specifying the number of individuals in each cell.
#' @return a matrix of lists defining the metacommunity (see details).
#' 
#' @export

populate_landscape = function(land, species, gsad=NULL, K, distribution=NA, p=NA, which_cells=NULL){
	
	# Dimensions of landscape
	X = nrow(land)
	Y = ncol(land)

	# Make carrying capacity matrix, if not specified
	if(length(K)==1){
		K_mat = matrix(K, nrow=X, ncol=Y)
	} else {
		K_mat = K
	}

	# Catch error if landscape and K_mat do not match
	# Note that land may be a raster layer so dim() will not match
	if(nrow(K_mat)!=X | ncol(K_mat)!=Y) stop('Dimensions of land and K_mat must match.')

	# Number of species
	N_S = dim(species)[1]

	# Define global species abundance distribution
	if(is.null(gsad)) gsad = rep(1, N_S)
	gsad = gsad/sum(gsad)

	# Define parameters to default values is unspecified
	if(is.na(distribution)&is.null(which_cells)) distribution = 'same'
	if(is.na(distribution)&!is.null(which_cells)) distribution = 'designated'
	if(is.na(p)) p = 1


	# Make matrix to hold metacommunity. Integers indicate which species is present in each space.
	metacomm = matrix(list(), nrow=X, ncol=Y)
	for(i in 1:X){
	for(j in 1:Y){
		metacomm[i,j] = list(rep(0,K_mat[i,j]))
	}}

	# All cells receive the same proportion of their carrying capacity
	if(distribution=='same'){
		for(i in 1:X){
		for(j in 1:Y){
			k = length(unlist(metacomm[i,j]))
			n = floor(p*k)
			if(n>0) metacomm[i,j][[1]][1:n] = sample(N_S, size=n, replace=T, prob=gsad) 
		}}
	}

	# Metacommunity receives fixed proportion of total carrying capacity with individuals distributed uniformly
	if(distribution=='uniform'){
		k = sum(K_mat)
		n = floor(k*p)
		inds = sample(N_S, size=n, replace=T, prob=gsad)
		
		# Keep track of which cells have been filled
		cell_full = matrix(F, nrow=X, ncol=Y)	
	
		for(x in inds){
			# Find cells with spaces available
			available = which(!cell_full, arr.ind=T)
			this_cell = available[sample(nrow(available), 1),]

			# Find an available space in this cell
			these_spots = metacomm[this_cell[1], this_cell[2]][[1]]
			this_spot = which(these_spots==0)[1]

			# Assign this individual to this cell
			metacomm[this_cell[1], this_cell[2]][[1]][this_spot] = x

			# Record whether the cell is now full
			if(this_spot==length(these_spots)) cell_full[this_cell[1], this_cell[2]] = T		
		}

	}

	# Individuals placed in designated cells only.
	if(distribution=='designated'){
	
		# Catch error if locations not specified
		if(is.null(which_cells)) stop("Must specify which_cells if distribution is 'designated'.")
		
		# Assign individuals to each specified cell
		# Currently adds fixed proportion 'p' as default if exact number of individuals for each cell are unspecified.
		for(r in 1:nrow(which_cells)){
			i = which_cells[r,1]
			j = which_cells[r,2]
			k = length(unlist(metacomm[i,j]))
			n = ifelse(ncol(which_cells)==3, which_cells[r,3], floor(k*p)) # THROWS AN ERROR

			if(n > k) stop(paste0('More individuals specified than carrying capacity of cell (',i,',',j,')'))
				
			metacomm[i,j][[1]][1:n] = sample(N_S, size=n, replace=T, prob=gsad)
		}		
	}

	# Return initial metacommunity
	metacomm
}
