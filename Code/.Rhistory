this_land = lands_N[[j]]
this_species = species_N[[j]]
this_gsad = gsad_N[[j]]
# Distribute species across landscape
this_metacomm = with(parms, {
p = ifelse(exists('prop_full'), prop_full, NA)
distribution = ifelse(exists('init_distribute'), init_distribute, NA)
if(exists('cells_distribute')){
which_cells = cells_distribute
} else {
which_cells = NULL
}
populate_landscape(this_land, this_species, this_gsad, K, distribution, p, which_cells)
})
# Run simulation
results = with(parms, {
if(!exists('d_kernel')) d_kernel = NULL
if(!exists('v_kernel')) v_kernel = NULL
imm_rate = ifelse(exists('imm_rate'), imm_rate, NA)
if(!exists('save_steps')) save_steps = NULL
if(!exists('calc_rates')) calc_rates = F
run_sim(nsteps, this_metacomm, this_land, this_species, this_gsad, d_kernel, v_kernel, imm_rate,
save_steps, report, ID=j, calc_rates=calc_rates)
})
# Save results
save(results, this_species, this_land, this_metacomm, this_gsad, file=this_runfile)
gc()
}
}
sim_complete=T
stopCluster(cluster)
} else {
stop('doParallel or foreach not found. Cannot run simulation in parallel without these package.')
# Simulate runs sequentially
}
} else {
# If this is not a restart of a previous simulation
if(!restart){
# Initialize simulation landscapes
lands_N = lapply(1:nruns, function(j){
with(parms, {
x = dimX
y = dimY
if(!exists('vgm_mod')) vgm_mod = NULL
d = ifelse(exists('vgm_dcorr'), vgm_dcorr, NA)
prop = ifelse(exists('habA_prop'), 1-habA_prop, 0.5)
make_landscape(x, y, vgm_mod, d, prop, draw_plot=F)
})
})
# Report progress
if(report>0) print(paste0(Sys.time(), ': Finished making landscapes.'))
# Initialize species vital rates
species_N = lapply(1:nruns, function(j){
with(parms, {
S_AB = ifelse(exists('S_AB'), S_AB, NA)
if(!exists('dist_b')) dist_b = NULL
m = m_rates
r = r_rates
if(!exists('dist_d')) dist_d = NULL
if(!exists('dist_v')) dist_v = NULL
make_species(S_A, S_B, S_AB, dist_b, m, r, dist_d, dist_v)
})
})
# Report progress
if(report>0) print(paste0(Sys.time(), ': Finished making species pools.'))
# Initialize global species abundance distribution
gsad_N = lapply(1:nruns, function(j){
with(parms, {
N_S = dim(species_N[[j]])[1]
if(exists('dist_gsad')){
if(is.list(dist_gsad)){
# Use specified distribution to generate abundances
distribution = dist_gsad
gsad_vec = make_sad(N_S, distribution)
} else {
# Make global abundaces equal to species birth rates
if(dist_gsad=='b_rates'){
A_rates = species_N[[j]][1:S_A,'A','b']
B_rates = species_N[[j]][(S_A+1):(S_A+S_B),'B','b']
gsad_vec = c(A_rates, B_rates)
if(exists('S_AB')) if(S_AB > 0) gsad_vec = c(gsad_vec, rowMeans(species_N[[j]][(S_A+S_B+1):(S_A+S_B+S_AB),,'b']))
} else {
stop('Unrecognized value for parameter dist_gsad.')
}
}
# Defaults to same abundance for each species
} else {
distribution = list(type='same')
gsad_vec = make_sad(N_S, distribution)
}
# Return vector of global abundances
gsad_vec
})
})
# Report prgress
if(report>0) print(paste0(Sys.time(), ': Finished making gsads.'))
# Save simulation objects
save(lands_N, species_N, gsad_N, file=file.path(save_dir, 'sim_objects.RData'))
# If this is a restart of a previous run
} else {
# Read in lands, species, gsads from directory where simulation results saved
load(file.path(save_dir, 'sim_objects.RData'))
}
# Run simulations
for(j in 1:nruns){
# Define file to save results
this_runfile = file.path(save_dir, paste0(simID, '_run', j, '.RData'))
# Check whether this is a restart and whether this run has already be done
if(restart & file.exists(this_runfile)){
if(report>0) print(paste0(Sys.time(), ': Skipping run ', j))
} else {
# Report progress
if(report>0) print(paste0(Sys.time(), ': Start run ', j))
# Define this landscape and species pool
this_land = lands_N[[j]]
this_species = species_N[[j]]
this_gsad = gsad_N[[j]]
# Distribute species across landscape
this_metacomm = with(parms, {
p = ifelse(exists('prop_full'), prop_full, NA)
distribution = ifelse(exists('init_distribute'), init_distribute, NA)
if(exists('cells_distribute')){
which_cells = cells_distribute
} else {
which_cells = NULL
}
populate_landscape(this_land, this_species, this_gsad, K, distribution, p, which_cells)
})
# Run simulation
results = with(parms, {
if(!exists('d_kernel')) d_kernel = NULL
if(!exists('v_kernel')) v_kernel = NULL
imm_rate = ifelse(exists('imm_rate'), imm_rate, NA)
if(!exists('save_steps')) save_steps = NULL
if(!exists('calc_rates')) calc_rates = F
run_sim(nsteps, this_metacomm, this_land, this_species, this_gsad, d_kernel, v_kernel, imm_rate,
save_steps, report, ID=j, calc_rates=calc_rates)
})
# Save results
save(results, this_species, this_land, this_metacomm, this_gsad, file=file.path(save_dir, paste0(simID, '_run', j, '.RData')))
gc()
}
}
sim_complete=T
}
# Read individual runs back into a list
if(return_results & sim_complete){
sim_results = lapply(1:nruns, function(j){
this_run = file.path(save_dir, paste0(simID, '_run', j, '.RData'))
load(this_run)
if(is.null(save_sim))  file.remove(this_run)
results
})
# Save results
sim_results = list(results = sim_results, species = species_N, lands = lands_N, gsads = gsad_N)
if(!is.null(save_sim)){
save(sim_results, file=file.path(save_dir, paste0(simID, '_results.RData')))
}
# Return results
sim_results
}
}
#' Creates a landscape as a grid with two habitat types represented by a raster
#' 	 of 1 and -1.
#'
#' @note Habitat heterogeneity increases as the ratio between \code{d} and grid
#' 	dimensions decreases. WARNING: long compute time on grids > 50 x 50.
#'
#' @param x (required) number of cells in the x dimension, or a vector of the x and y
#' 	dimensions
#' @param y number of cells in the y dimension
#' @param mod variogram model used to generate spatial autocorrelation
#' 	(see  \code{\link{vgm}}).
#' 	Defaults to Exponential model with partial sill = 1.
#' @param d range of the variogram model. Defines the distance at which cells
#' 	are correlated. Defaults to 1/3 of the smallest dimension.
#' @param prop proportion of cells assigned to have value = -1 (type 'A').
#' @param draw_plot logical indicating whether function should plot the
#' 	landscape
#' @return a raster object
#' @seealso \code{\link{vgm}} for how to specify variogram model
#'
#' @import gstat
#' @import sp
#' @import raster
#' @export
make_landscape = function(x=NULL, y=NA, mod=NULL, d=NA, prop=NA, draw_plot=F){
# Catch error if no dimensions specified
if(is.null(x)&is.na(y)){ stop('Must supply grid dimensions.') }
if(is.na(y)&length(x)==2){
y = x[2]
x = x[1]
}
if(is.na(y)) { stop('Must supply grid dimensions.') }
# Define coordinates
locs = expand.grid(1:x, 1:y)
names(locs) = c('x','y')
# Define spatial model with an expected value of 0 and no spatial trend (by universal kriging)
# See vgm() in gstat package for explanation of spatial correlation models
# Range defaults to 1/3 of the smallest grid dimension
if(is.null(mod)){
mod = gstat::vgm(psill=1, model='Exp', range=ifelse(is.na(d), min(x/3,y/3), d))
}
spatial_model = gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=mod)
# Define proportion habitat B if unspecified
if(is.na(prop)) prop = 0.5
# Simulate values at locations
values = predict(spatial_model, locs, nsim=1)
# Convert to spatial data and raster grid
sp::gridded(values) = ~x+y
values_grid = raster::raster(values)
# Threshold to binary habitat based on proportion of habitat in each type
threshold = raster::quantile(values_grid, prop)
binary_grid = values_grid > threshold
binary_grid[binary_grid==0] = -1
# Draw landscape
if(draw_plot) plot(binary_grid)
# Return landscape
binary_grid
}
# Check that required parameters are present
if(!exists('nruns', environment())|!exists('simID', environment())){
warning(paste(f,'may not contain simID or nruns. Simulation NOT run.'))
} else {
# Run simulations
run_sim_N(nruns, parm_list, ncores, simID, save_sim=results_dir,
report=report, return_results=F, restart=restart, lib_loc=sim_dir)
}
results_dir ="/Users/sheldontaylor/core-transient-simulation/Results/Summary/EXP3.5/d-g1"
# Check that required parameters are present
if(!exists('nruns', environment())|!exists('simID', environment())){
warning(paste(f,'may not contain simID or nruns. Simulation NOT run.'))
} else {
# Run simulations
run_sim_N(nruns, parm_list, ncores, simID, save_sim=results_dir,
report=report, return_results=F, restart=restart, lib_loc=sim_dir)
}
ncore = 4
ncores = 4
# Check that required parameters are present
if(!exists('nruns', environment())|!exists('simID', environment())){
warning(paste(f,'may not contain simID or nruns. Simulation NOT run.'))
} else {
# Run simulations
run_sim_N(nruns, parm_list, ncores, simID, save_sim=results_dir,
report=report, return_results=F, restart=restart, lib_loc=sim_dir)
}
sim_dir=NULL
report=0
restart=F
# Check that required parameters are present
if(!exists('nruns', environment())|!exists('simID', environment())){
warning(paste(f,'may not contain simID or nruns. Simulation NOT run.'))
} else {
# Run simulations
run_sim_N(nruns, parm_list, ncores, simID, save_sim=results_dir,
report=report, return_results=F, restart=restart, lib_loc=sim_dir)
}
library(CTSim)
install.packages("CTSim")
?checkForRemoteErrors
# Load packages needed to build CTSim
library(devtools)
library(roxygen2)
library(gstat)
setwd('C:/git/core-transient-simulation/Code/')
# /Users/sheldontaylor/core-transient-simulation/Code/
current_code = as.package('CTSim')
# Load functions
load_all(current_code)
# Update documentation
document(current_code)
# Add Imports and Suggests to DESCRIPTION
setwd('./CTSim')
use_package('abind')
use_package('fdrtool')
use_package('gstat')
use_package('poweRlaw')
use_package('raster')
use_package('reshape2')
use_package('sads')
use_package('sp')
use_package('doParallel','Suggests')
use_package('foreach','Suggests')
# Check the package
setwd('../')
check('CTSim')
# Build the package
build('CTSim')
#build_win('CTSim')
# Check install
install.packages('CTSim_0.1.7.zip')
library(CTSim)
# Make static html documentation
#build_site('CTSim')
################################################### DO NOT RUN THIS, D/N WORK
### Misc code for testing functions
library(raster)
# Testing Functions
myland = make_landscape(c(5,5), prop=.5)
mysp = make_species(3, 4, dist_b=list(type='same', p1=2),
m=c(.5, .5), r=c(1, .5), dist_d=list(mu=1, var=0), dist_v=list(mu=c(0,.8), var=c(0,.02), type='adjacent')
)
mygsad = sapply(1:7, function(i) mysp[i, get_sptype(mysp)[i],'b'])
mymeta = populate_landscape(myland, mysp, mygsad, K=10, distribution='uniform', p=.8)
mymeta_t1 = run_timestep(mymeta, myland, mysp, mygsad, d_kernel=list(type='gaussian'),
v_kernel=list(type='adjacent', moves=2), imm_rate=.2
)
mymeta_t20 = run_sim(20, mymeta, myland, mysp, mygsad, d_kernel=list(type='gaussian'),
v_kernel=list(type='adjacent', moves=2), imm_rate=.2, save_steps=seq(2, 20, 2),
report=2, ID='testrun', calc_rates=T
)
mymeta_t8 = run_sim(8, mymeta, myland, mysp, mygsad, d_kernel=list(type='gaussian'),
v_kernel=list(type='adjacent', moves=2), imm_rate=.2, save_steps=seq(2, 8, 2),
report=2, ID='testrun'
)
# Testing summary functions
setwd('/Users/sheldontaylor/core-transient-simulation/scratch')
run_sim_P(2, report=2)
run_sum = summarize_sim_P('d-a0_v-a0_dcorr-1')
load('Summaries/test_summary.RData') # d/n work
# Check summary manually
load('Results/d-a0_v-a0_dcorr-1/d-a0_v-a0_dcorr-1_run1.RData')
mylocs = aggregate_cells(X=c(5,5), dX=c(2,2), form='partition')
mylocs = aggregate_cells(X=c(5,5), dX=c(1,1), form='partition')
calc_abun(mymeta_t1, N_S=20, only_species=T)
myabuns = calc_abun_profile(mylocs, list(start=1, stop=10), mymeta_t10, 20)
myocc = calc_occupancy(abuns = myabuns)
calc_abun_CT(myabuns, myocc, seq(.1, .9, .1))
hab = sapply(mylocs, function(x) average_habitat(x, myland))
trates = calc_species_turnover(mymeta_t20$turnover, mylocs, 20, which_species=c(1,1,1,2,2,2,2))
tapply(trates[1,,'gain',1], hab, mean)
tapply(trates[1,,'gain',2], hab, mean)
tapply(trates[1,,'loss',1], hab, mean)
tapply(trates[1,,'loss',2], hab, mean)
data.frame(hab, trates[1,,,1], trates[1,,,2])
myobs = sapply(c(.5, .8), function(p) sample_sim(myabuns, p), simplify='array')
mysumA= summarize_sim(mymeta_t20, .5, mylocs, list(start=10, stop=20), mysp, myland, mygsad,
P_obs=1, sum_parms=list(time_sum='none', hab='A'),sum_turn=T)
mysumA= summarize_sim(mymeta_t20, .5, mylocs, list(start=10, stop=20), mysp, myland, mygsad,
P_obs=1, sum_parms=list(time_sum='none', hab='A'))
mysumB= summarize_sim(mymeta_t20, .5, mylocs, list(start=10, stop=20), mysp, myland, mygsad,
agg_times=3, P_obs=1, sum_parms=list(time_sum='mean', hab='B'))
mysum =  summarize_sim(mymeta_t8, .5, mylocs, list(start=1, stop=8), mysp, myland, mygsad,
P_obs=1, sum_parms=list(time_sum='none', hab='AB'))
hab = aggregate_hab_type(myland, mylocs)
mylocs
mymeta_t10$turnover
setwd("/Users/sheldontaylor/core-transient-simulation/Code/")
current_code = as.package('CTSim')
# Load functions
load_all(current_code)
# Update documentation
document(current_code)
# Add Imports and Suggests to DESCRIPTION
setwd('./CTSim')
use_package('abind')
use_package('fdrtool')
use_package('gstat')
use_package('poweRlaw')
use_package('raster')
use_package('reshape2')
use_package('sads')
use_package('sp')
use_package('doParallel','Suggests')
use_package('foreach','Suggests')
# Check the package
setwd('../')
check('CTSim')
# Build the package
build('CTSim')
#build_win('CTSim')
# Check install
install.packages('CTSim_0.1.7.zip')
library(CTSim)
# Make static html documentation
#build_site('CTSim
library(CTSim)
# Check that required parameters are present
if(!exists('nruns', environment())|!exists('simID', environment())){
warning(paste(f,'may not contain simID or nruns. Simulation NOT run.'))
} else {
# Run simulations
run_sim_N(nruns, parm_list, ncores, simID, save_sim=results_dir,
report=report, return_results=F, restart=restart, lib_loc=sim_dir)
}
install.packages("CTSim")
3 +4
?vector
3 + 4
3*4
3/4
3^4
x <- 3 + 4
x
y <- 2 + x
y
ls()
vars <- ls()
vars
class(vars)
class(x)
class()
var1 <- c(1,2,3)
var1
var2 <- c("1","2","3")
var2
var3 <- c("a", "b", "c")
var3
class(var1)
class(var2)
class(var3)
var1 +var2
1 < 2
1 > 2
1 = 1
1 == 1
1 >= 1
1 >= -1
"1" == 1
ls()
rm var1
rm(var1)
var1 <- c(1,2,3)
class(c(var1, var2))
c(var1, var2)
is(object = TRUE, class2 = "logical")
as(object = TRUE, Class = "numeric")
?as
as(TRUE,"numeric")
as(object = FALSE, Class = "numeric")
is.character(TRUE)
is.logical(FALSE)
as.character(TRUE)
as.numeric("1")
as.numeric("a")
as.logical("a")
as.logical("1")
as.logical(as.numeric("1"))
as.logical(as.numeric("1")
)
as.logical(1)
as.logical(0)
NA == 1
var1 <- c(1,2,3)
var1
var4 <- c(var1, var2)
var4
mat1 <- matrix(data = 1:6, nrows =2, ncol = 3)
mat1 <- matrix(data = 1:6, nrow =2, ncol = 3)
mat1
mat1 <- matrix(data = 1:6, nrow =2, ncol = 3, byrow = TRUE)
mat1
matrix(data = c(TRUE, FALSE, TRUE, TRUE, FALSE), nrow = 3, ncol = 2)
matrix(data = c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE), nrow = 3, ncol = 2)
matrix(data = c("a", "b", "c", "d", "e", "f"), nrow = 3, ncol = 2)
?matrix
l1 <- list(c(1,2,3), c("a", "b", "c"))
l1
l1 <- list(c(1,2,3,"a", "b", "c"))
l1
l1 <- list(c(1,2,3), c("a", "b", "c"))
l1
names(l1)
names(l1) <- c("vec1", "vec2")
l1
l2 <- list(vec = c(1,3,5,7,9), mat = matrix(data = c(1,2,3), nrow = 3))
l2
df1 <- data.frame(x = 1:3, y = c("a", "b", "c"))
df1
class(df1)
df1 <- data.frame(x = 1:3, y = c("a", "b", "c"), byrow = TRUE)
df1
df1 <- data.frame(x = 1:3, y = c("a", "b", "c"))
df1
str(df1)
df1 <- data.frame(x = 1:3, y = c("a", "b", "c"), stringsAsFactors = FALSE)
str(df1)
v1 <- c("a", "b", "c", "d")
v1[3]
v1[c(1,3)]
l1
l1$vec1[2]
l1[[1]]
l1$vec1
l1[["vec1"]]
mat1
mat1[2,1]
mat1[2,]
mat1[,1]
df1
df[1]
df[1,1]
df1[1,1]
df1[1]
df1$x
df1$y
df1[1,]
df1[,1]
df1
df1[2,1] <- 4
df1
df1$z <- "squirrels"
df1
df1$z <- 1:3
df1
newvar <- c(171, 360, 38, 351, 393, 25)
mean(newvar)
median(newvar)
sd(newvar)
summary(newvar)
l1
