# Calculate species occupancy
occ = sapply(1:length(P_obs), function(i){
use_abun = abuns_obs[,,,i, drop=FALSE]
use_abun = abind::adrop(use_abun, 4)
calc_occupancy(abuns=use_abun, agg_times=NULL, do_freq=F)
}, simplify='array')
# dims are now: [spatial unit, species, P]
# Flatten occupancy data
occ2 = apply(occ, 2, I) %>% data.frame() %>%
mutate(pix = rep(1:1024, times = 10),
p = rep(seq(0.1, 1, 0.1), each = 1024)) %>%
gather("sp", "occ", 1:40) %>%
mutate(sp = as.numeric(substr(sp, 2, nchar(sp))))
breaks = seq(ct_threshold, 0.9999, by = ct_threshold)
# Get species birth rates
b_rates = species[,,'b']
# Get habitat types for spatial units
habitats = sapply(locs, function(x) average_habitat(x, land))
# Calculate classification of species based on birth rates
cores = t(sapply(habitats, function(h) b_rates[,h]>0))
classification = apply(cores, 1:2, function(x) ifelse(x, 'core', 'trans'))
# compare classification to occupancy-based designation
xclass.sp = sapply(1:length(P_obs), function(i){
use_occ = occ[,,i, drop=FALSE]
use_occ = abind::adrop(use_occ, 3)
xclass = classification
xclass[classification == 'core' & use_occ > (1 - ct_threshold)] = 'c-c'
xclass[classification == 'core' & use_occ <= ct_threshold & use_occ > 0] = 'c-t'
xclass[classification == 'trans' & use_occ > (1 - ct_threshold)] = 't-c'
xclass[classification == 'trans' & use_occ <= ct_threshold & use_occ > 0] = 't-t'
xclass[xclass == 'core'] = 'c-int'  # biologically core but intermediate occupancy
xclass[xclass =='trans'] = 't-int'  # biologically transient but intermediate occupancy
xclass[use_occ == 0] = NA           # absent over the time period
return(xclass)
}, simplify='array')
# Calculate landscape similarity to focal pixel
loc.xy = matrix(unlist(locs), ncol = 2, byrow = TRUE)
landsim = land_similarity(loc.xy, land, scale)
landscapeS = data.frame(pix = 1:1024, x = loc.xy[,1], y = loc.xy[,2], sim = landsim)
# xclass.sp flattened out into 2 dimensions
#   (rows increase in pixel.id first, then species, then P_obs)
#   and then adding in landscape sim, abundances, etc
xc2 = apply(xclass.sp, 2, I) %>% data.frame() %>%
mutate(pix = rep(1:1024, times = 10),
p = rep(P_obs, each = 1024)) %>%
gather("sp", "xc", 1:40) %>%
mutate(sp = as.numeric(substr(sp, 2, nchar(sp)))) %>%
full_join(landscapeS, by = "pix") %>%
filter(x > scale & x < max(x) - scale & y > scale & y < max(y) - scale,
!is.na(xc)) %>%
inner_join(sad.cell, by = c("pix", "sp")) %>%
inner_join(sad.grid, by = "sp") %>%
inner_join(occ2, by = c("pix", "p", "sp")) %>%
arrange(pix, p, sp) %>%
select(pix, sim, p, sp, Ncell, Ngrid, occ, xc)
return(xclass = xc2)
}
xclass.out = c()
land.out = c()
xclass.ct = c()
scale = 3
for (r in 1:50) {
temp = pixelXclass(datadir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3, return = 'percent')
tmp = pixelXclass(datadir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3, return = 'count')
# Eliminate pixels within a distance 'scale' from the grid edge
temp2 = temp$xclass[temp$landSim$x > scale & temp$landSim$x < max(temp$landSim) - scale &
temp$landSim$y > scale & temp$landSim$y < max(temp$landSim) - scale ,,]
xclass.out = abind(xclass.out, temp2, along = 1)
tmp2 = tmp$xclass[tmp$landSim$x > scale & tmp$landSim$x < max(tmp$landSim) - scale &
tmp$landSim$y > scale & tmp$landSim$y < max(tmp$landSim) - scale ,,]
xclass.ct = abind(xclass.ct, tmp2, along = 1)
land2 = temp$landSim[temp$landSim$x > scale & temp$landSim$x < max(temp$landSim) - scale &
temp$landSim$y > scale & temp$landSim$y < max(temp$landSim) - scale ,,]
land.out = rbind(land.out, land2)
print(paste(r, Sys.time()))
}
datadir = '/Users/sheldontaylor/core-transient-simulation/d-g2_imm-0.001'
xclass.out = c()
land.out = c()
xclass.ct = c()
scale = 3
for (r in 1:50) {
temp = pixelXclass(datadir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3, return = 'percent')
tmp = pixelXclass(datadir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3, return = 'count')
# Eliminate pixels within a distance 'scale' from the grid edge
temp2 = temp$xclass[temp$landSim$x > scale & temp$landSim$x < max(temp$landSim) - scale &
temp$landSim$y > scale & temp$landSim$y < max(temp$landSim) - scale ,,]
xclass.out = abind(xclass.out, temp2, along = 1)
tmp2 = tmp$xclass[tmp$landSim$x > scale & tmp$landSim$x < max(tmp$landSim) - scale &
tmp$landSim$y > scale & tmp$landSim$y < max(tmp$landSim) - scale ,,]
xclass.ct = abind(xclass.ct, tmp2, along = 1)
land2 = temp$landSim[temp$landSim$x > scale & temp$landSim$x < max(temp$landSim) - scale &
temp$landSim$y > scale & temp$landSim$y < max(temp$landSim) - scale ,,]
land.out = rbind(land.out, land2)
print(paste(r, Sys.time()))
}
temp = pixelXclass(datadir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3, return = 'percent')
datadir = '/Users/sheldontaylor/core-transient-simulation'
temp = pixelXclass(datadir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3, return = 'percent')
datadir = '/Users/sheldontaylor/core-transient-simulation/d-g2_imm-0.001'
tmp = pixelXclassBySpecies(data_dir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3)
datadir = '/Users/sheldontaylor/core-transient-simulation'
tmp = pixelXclassBySpecies(data_dir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3)
CTSim
?CTSim
## This script is used to visualize simulation summaries from EXP 3
#   (specifically where dispersal is set as a Gaussian (99% within 2 pixels),
#   and immigration to any pixel from the metacommunity is 0.001.)
# Set options and load libraries
options(stringsAsFactors=F)
library(CTSim)
library(dplyr)
library(tidyr)
library(abind)
library(reshape2)
# Define working directory
sum_dir = 'Results/Summary/EXP3'
fig_dir = 'Results/Plots/EXP3'
sim_dir = 'Code'
datadir = '/Users/sheldontaylor/core-transient-simulation/d-g2_imm-0.001'
# Load simulation functions
#source(file.path(sim_dir, 'simulation_functions.R'))
##########################
## Functions
# A function that extracts parameter values from a runID
#	runID = a string in the filename that gives the parameters
#	assoc_str = character pairing a parameter name with its value
#	sep_str = character separating different parameter-value pairs
get_parms = function(runID, assoc_str='-', sep_str='_'){
parm_pairs = sapply(strsplit(runID, sep_str), function(x) strsplit(x, assoc_str))
vals = sapply(parm_pairs, function(x) x[2])
vals = as.data.frame(t(vals))
names(vals) = sapply(parm_pairs, function(x) x[1])
vals
}
make_plot = function(xlim, ylim, xlab=NULL, ylab=NULL, cex=1){
plot.new()
plot.window(xlim=xlim, ylim=ylim)
axis(1)
abline(h=par('usr')[3], lwd=3)
axis(2, las=1)
abline(v=par('usr')[1], lwd=3)
if(!is.null(xlab)) mtext(xlab, 1, 2.5, cex=cex)
if(!is.null(ylab)) mtext(ylab, 2, 3, cex=cex)
}
# Function to plot core/transient dynamics for a pixel
pixDyn = function(results, this_land, row, col, lab = NULL, timewindow = NULL, scale = 3) {
if(this_land[row, col] == 1) { hab = 'A' } else { hab = 'B' }
if(!is.null(lab)) { lab = paste(lab, "; ", sep = '') }
# Fraction of identical landscape over (2*scale+1)x(2*scale+1) region
het = sum(this_land[max(row-scale, 1):min(row+scale, 32), max(col-scale, 1):min(col+scale, 32)] == this_land[row, col])/
length(this_land[max(row-scale, 1):min(row+scale, 32), max(col-scale, 1):min(col+scale, 32)])
# Species #1-20 are by definition core in Habitat B; species 21-40 in Habitat A
if (hab == 'B') {
core = unlist(lapply(results[row, col, ], function(x) sum(unique(x) <= 20)))
tran = unlist(lapply(results[row, col, ], function(x) sum(unique(x) > 20)))
} else {
core = unlist(lapply(results[row, col, ], function(x) sum(unique(x) > 20)))
tran = unlist(lapply(results[row, col, ], function(x) sum(unique(x) <= 20)))
}
plot(core, type = 'l', xlab = 'Time', ylab = 'Number of species', col = 'skyblue',
main = paste(lab, "Landscape similarity ", round(het,2), ";\ncore (blue), transient (red)", sep = ''),
lwd = 2, ylim = c(0, max(c(core, tran))))
points(tran, type = 'l', col = 'red', lwd = 2)
# Optionally plot % transient species aggregated over timewindow
if(!is.null(timewindow)) {
pct.trans = c()
times = timewindow*1:floor(200/timewindow) - timewindow/2
for (t in 1:floor(200/timewindow)) {
uniqsp = unique(unlist(results[row, col, ((t-1)*timewindow + 2):(t*timewindow+1)]))
if (hab == 'A') {
pct.trans = c(pct.trans, sum(uniqsp <= 20)/length(uniqsp))
} else {
pct.trans = c(pct.trans, sum(uniqsp > 20)/length(uniqsp))
}
}
par(new=T)
plot(times, pct.trans, xlim = c(0,200), ylim = c(0,1), xlab = '', ylab = '', yaxt = 'n',
xaxt = 'n', type = 'l')
axis(4, at = seq(0,1, by = 0.25), tcl = .3, labels = F)
mtext(c(1.0, 0.5, 0), 4, at = c(1, .5, 0), cex = .75)
}
}
# Plot occupancy histogram for the final time window 162:201 (time 161:200)
pixOccHist = function(results, row, col, lab, timewindow = 40, binwidth = 4) {
tmp = results[row, col, (202 - timewindow):201]
unq = lapply(tmp, function(x) unique(x))
occs = table(unlist(unq))
# Define histogram breaks
xrange = seq(0, timewindow, binwidth)
# Split into two groups (species ID <= or > 20)
ocore = occs[as.numeric(names(occs)) <= 20]
otran = occs[as.numeric(names(occs)) > 20]
# compute the counts per interval
hv1 = hist(ocore,breaks=xrange,plot=F)$counts
hv2 = hist(otran,breaks=xrange,plot=F)$counts
# Generate a a stacked histogram
barplot(rbind(hv1,hv2), col=c("#FF0000FF", "#FFFFBFFF"), names.arg = xrange[-1]/timewindow,
space = 0, las = 1, ylab = "Number of species", xlab = "Occupancy",
main = paste("Pixel", lab))
}
# Generic (fixed pixel location) dynamics for any simulation run
# data_dir : directory where raw simulation results are stored
# sim      : sim name specifying parameter combinations, e.g. hp-0.9
# run      : simulation run #
# plot_dir : directory for saving output plot
pixelSummary = function(data_dir, sim, run=1:20, plot_dir, plot.pdf = TRUE) {
if (plot.pdf) {
pdf(paste(plot_dir, '/', sim, '_run', run[1],'-',run[length(run)], '_dynamics.pdf', sep = ''),
height = 10, width = 8)
}
par(mfrow = c(4,3))
for (r in run) {
suppressWarnings(rm(list = c('results', 'res', 'this_land', 'this_metacomm', 'this_species')))
load(paste(data_dir, '/', sim, '_run', r, '.Rdata', sep = ''))
# Results from early sims (pre-turnover) are in slightly different structure
if (class(results) == 'array') {
res = results
} else {
res = results$sim
}
image(this_land, main = paste(sim, '_run', r, sep = ''))
# Gridded pixels for investigation
sites = data.frame(id = c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'),
row = c(5, 5, 5, 16, 16, 16, 16, 28, 28, 28, 28),
col = c(5, 16, 27, 4, 12, 20, 28, 4, 12, 20, 28))
text(sites$col, 33-sites$row, sites$id, cex = .5)
sapply(1:nrow(sites), function(x) pixDyn(res, this_land, sites$row[x], sites$col[x], sites$id[x], timewindow = 40))
image(this_land, main = paste(sim, '_run', r, sep = ''))
text(sites$col, 33-sites$row, sites$id, cex = .5)
sapply(1:nrow(sites), function(x)
pixOccHist(res, sites$row[x], sites$col[x], sites$id[x], timewindow = 40, binwidth = 4))
}
if (plot.pdf) {
dev.off()
}
}
# Calculate similarity of landscape to focal pixel
# (Fraction of identical landscape over (2*scale+1)x(2*scale+1) region)
#   loc.xy is a matrix of x and y coordinates on the landscape grid
#   land is the landscape grid raster
#   scale is the (square) radius over which similarity is calculated
land_similarity = function(loc.xy, land, scale) {
het = apply(loc.xy, 1, function(i) {
sum(land[max(i[1]-scale, 1):min(i[1]+scale, 32), max(i[2]-scale, 1):min(i[2]+scale, 32)] == land[i[1], i[2]])/
length(land[max(i[1]-scale, 1):min(i[1]+scale, 32), max(i[2]-scale, 1):min(i[2]+scale, 32)])
})
return(het)
}
# Generic pixel cross-classification analysis for all (non-edge) pixels
# data_dir : directory where raw simulation results are stored
# sim      : sim name specifying parameter combinations, e.g. hp-0.9
# run      : simulation run #
# scale    : radius in pixels over which landscape heterogeneity is calculated
pixelXclass = function(data_dir, sim, run=1, scale = 3, t_window = 186:200,
ct_threshold = 1/3, return = 'percent') {
timewindow = length(t_window)
suppressWarnings(rm(list = c('results', 'res', 'this_land', 'this_metacomm', 'this_species')))
load(paste(data_dir, '/', sim, '_run', run, '.Rdata', sep = ''))
# Results from early sims (pre-turnover) are in slightly different structure
if (class(results) == 'array') {
res = results
} else {
res = results$sim
}
# Check that required objects exist
if(!exists('this_species')|!exists('this_land')|!exists('this_gsad')){
stop(paste(sim, 'may not contain this_species, this_land, or this_gsad. Summary NOT run.'))
} else {
# Assign objects
species = this_species
land = this_land
gsad = this_gsad
}
# Number of species
N_S = dim(species)[1]
# Define different scales of spatial aggregation (in a partition of the grid)
# Must supply grid dimensions
scale_locs = sapply(2^c(0:4), function(fact) aggregate_cells(X=c(32,32), dX=fact, dY=fact, form='partition'))
# Locations to be aggregated and evaluated
locs = scale_locs[[1]]
# Calculate species abundance profiles at the spatial and temporal resolution given by locs and t_window
abuns_act = calc_abun_profile(locs, t_window, res, N_S)
# Range of detection probabilities to examine
P_obs = seq(0.1, 1, by = .1)
# Apply observation bias
abuns_obs = sapply(P_obs, function(p){
sample_sim(abuns_act, probs = p, return='abundance')
}, simplify='array')
dimnames(abuns_obs)[[2]] = 1:N_S # Name columns with species names
# dims are now [timepoint, species, spatial unit, P]
# Calculate species occupancy
occ = sapply(1:length(P_obs), function(i){
use_abun = abuns_obs[,,,i, drop=FALSE]
use_abun = abind::adrop(use_abun, 4)
calc_occupancy(abuns=use_abun, agg_times=NULL, do_freq=F)
}, simplify='array')
# dims are now: [spatial unit, species, P]
breaks = seq(ct_threshold, 0.9999, by = ct_threshold)
# Get species birth rates
b_rates = species[,,'b']
# Get habitat types for spatial units
habitats = sapply(locs, function(x) average_habitat(x, land))
# Calculate classification of species based on birth rates
cores = t(sapply(habitats, function(h) b_rates[,h]>0))
classification = apply(cores, 1:2, function(x) ifelse(x, 'core', 'trans'))
# Calculate proportion mis-classified
xclass = sapply(1:length(P_obs), function(i){
use_occ = occ[,,i, drop=FALSE]
use_occ = abind::adrop(use_occ, 3)
tabs = cross_classify(use_occ, breaks, classification=classification, do_each=T, return='counts')
reshape2::acast(reshape2::melt(tabs, varnames=c('bio','occ','sp_unit')), sp_unit ~ bio+occ)
}, simplify='array')
# dims are now [spatial unit, category, P]
xclass.pct = array(dim = dim(xclass))
for (d in 1:dim(xclass)[1]) {
co = xclass[d,1:2,] #biologically core spp classified as either core or transient
tr = xclass[d,3:4,] #biologically transient spp classified as either core or transient
corepct = sapply(1:ncol(co), function(i) {
if (colSums(co)[i] == 0) {
c(NA, NA)
} else {
co[,i]/matrix(colSums(co)[i], nrow=1)
}
})
tranpct = sapply(1:ncol(tr), function(i) {
if (colSums(tr)[i] == 0) {
c(NA, NA)
} else {
tr[,i]/matrix(colSums(tr)[i], nrow=1)
}
})
xclass.pct[d,,] = rbind(corepct, tranpct)
}
loc.xy = matrix(unlist(locs), ncol = 2, byrow = TRUE)
landsim = land_similarity(loc.xy, land, scale)
landscapeS = data.frame(x = loc.xy[,1], y = loc.xy[,2], sim = landsim)
if(return == 'count') {
return(list(xclass=xclass, landSim = landscapeS))
} else if (return == 'percent') {
return(list(xclass = xclass.pct, landSim = landscapeS))
}
}
# Generic pixel cross-classification analysis for all (non-edge) pixels
# data_dir : directory where raw simulation results are stored
# sim      : sim name specifying parameter combinations, e.g. hp-0.9
# run      : simulation run #
# scale    : radius in pixels over which landscape heterogeneity is calculated
pixelXclassBySpecies = function(data_dir, sim, run=1, scale = 3, t_window = 186:200,
ct_threshold = 1/3) {
timewindow = length(t_window)
suppressWarnings(rm(list = c('results', 'res', 'this_land', 'this_metacomm', 'this_species')))
load(paste(data_dir, '/', sim, '_run', run, '.Rdata', sep = ''))
# Results from early sims (pre-turnover) are in slightly different structure
if (class(results) == 'array') {
res = results
} else {
res = results$sim
}
# Check that required objects exist
if(!exists('this_species')|!exists('this_land')|!exists('this_gsad')){
stop(paste(sim, 'may not contain this_species, this_land, or this_gsad. Summary NOT run.'))
} else {
# Assign objects
species = this_species
land = this_land
gsad = this_gsad
}
# Number of species
N_S = dim(species)[1]
# Define different scales of spatial aggregation (in a partition of the grid)
# Must supply grid dimensions
scale_locs = sapply(2^c(0:4), function(fact) aggregate_cells(X=c(32,32), dX=fact, dY=fact, form='partition'))
# Locations to be aggregated and evaluated
locs = scale_locs[[1]]
# Calculate species abundance profiles at the spatial and temporal resolution given by locs and t_window
abuns_act = calc_abun_profile(locs, t_window, res, N_S)
# Get total abundance of each species across the entire grid (remove 1st col describing empty cells)
sad.grid = data.frame(sp = 1:40, Ngrid = apply(abuns_act[, -1, ], 2, sum))
# Get abundance of each species in each pixel averaged over timewindow
sad.cell = t(apply(abuns_act[, -1, ], 2:3, sum)) %>% data.frame() %>%
mutate(pix = 1:1024) %>%
gather("sp", "Ncell", 1:40) %>%
mutate(sp = as.numeric(substr(sp, 2, nchar(sp))))
# Range of detection probabilities to examine
P_obs = seq(0.1, 1, by = .1)
# Apply observation bias
abuns_obs = sapply(P_obs, function(p){
sample_sim(abuns_act, probs = p, return='abundance')
}, simplify='array')
dimnames(abuns_obs)[[2]] = 1:N_S # Name columns with species names
# dims are now [timepoint, species, spatial unit, P]
# Calculate species occupancy
occ = sapply(1:length(P_obs), function(i){
use_abun = abuns_obs[,,,i, drop=FALSE]
use_abun = abind::adrop(use_abun, 4)
calc_occupancy(abuns=use_abun, agg_times=NULL, do_freq=F)
}, simplify='array')
# dims are now: [spatial unit, species, P]
# Flatten occupancy data
occ2 = apply(occ, 2, I) %>% data.frame() %>%
mutate(pix = rep(1:1024, times = 10),
p = rep(seq(0.1, 1, 0.1), each = 1024)) %>%
gather("sp", "occ", 1:40) %>%
mutate(sp = as.numeric(substr(sp, 2, nchar(sp))))
breaks = seq(ct_threshold, 0.9999, by = ct_threshold)
# Get species birth rates
b_rates = species[,,'b']
# Get habitat types for spatial units
habitats = sapply(locs, function(x) average_habitat(x, land))
# Calculate classification of species based on birth rates
cores = t(sapply(habitats, function(h) b_rates[,h]>0))
classification = apply(cores, 1:2, function(x) ifelse(x, 'core', 'trans'))
# compare classification to occupancy-based designation
xclass.sp = sapply(1:length(P_obs), function(i){
use_occ = occ[,,i, drop=FALSE]
use_occ = abind::adrop(use_occ, 3)
xclass = classification
xclass[classification == 'core' & use_occ > (1 - ct_threshold)] = 'c-c'
xclass[classification == 'core' & use_occ <= ct_threshold & use_occ > 0] = 'c-t'
xclass[classification == 'trans' & use_occ > (1 - ct_threshold)] = 't-c'
xclass[classification == 'trans' & use_occ <= ct_threshold & use_occ > 0] = 't-t'
xclass[xclass == 'core'] = 'c-int'  # biologically core but intermediate occupancy
xclass[xclass =='trans'] = 't-int'  # biologically transient but intermediate occupancy
xclass[use_occ == 0] = NA           # absent over the time period
return(xclass)
}, simplify='array')
# Calculate landscape similarity to focal pixel
loc.xy = matrix(unlist(locs), ncol = 2, byrow = TRUE)
landsim = land_similarity(loc.xy, land, scale)
landscapeS = data.frame(pix = 1:1024, x = loc.xy[,1], y = loc.xy[,2], sim = landsim)
# xclass.sp flattened out into 2 dimensions
#   (rows increase in pixel.id first, then species, then P_obs)
#   and then adding in landscape sim, abundances, etc
xc2 = apply(xclass.sp, 2, I) %>% data.frame() %>%
mutate(pix = rep(1:1024, times = 10),
p = rep(P_obs, each = 1024)) %>%
gather("sp", "xc", 1:40) %>%
mutate(sp = as.numeric(substr(sp, 2, nchar(sp)))) %>%
full_join(landscapeS, by = "pix") %>%
filter(x > scale & x < max(x) - scale & y > scale & y < max(y) - scale,
!is.na(xc)) %>%
inner_join(sad.cell, by = c("pix", "sp")) %>%
inner_join(sad.grid, by = "sp") %>%
inner_join(occ2, by = c("pix", "p", "sp")) %>%
arrange(pix, p, sp) %>%
select(pix, sim, p, sp, Ncell, Ngrid, occ, xc)
return(xclass = xc2)
}
#---------------------------------------------------------------------------------
xclass.out = c()
land.out = c()
xclass.ct = c()
scale = 3
for (r in 1:50) {
temp = pixelXclass(datadir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3, return = 'percent')
tmp = pixelXclass(datadir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3, return = 'count')
# Eliminate pixels within a distance 'scale' from the grid edge
temp2 = temp$xclass[temp$landSim$x > scale & temp$landSim$x < max(temp$landSim) - scale &
temp$landSim$y > scale & temp$landSim$y < max(temp$landSim) - scale ,,]
xclass.out = abind(xclass.out, temp2, along = 1)
tmp2 = tmp$xclass[tmp$landSim$x > scale & tmp$landSim$x < max(tmp$landSim) - scale &
tmp$landSim$y > scale & tmp$landSim$y < max(tmp$landSim) - scale ,,]
xclass.ct = abind(xclass.ct, tmp2, along = 1)
land2 = temp$landSim[temp$landSim$x > scale & temp$landSim$x < max(temp$landSim) - scale &
temp$landSim$y > scale & temp$landSim$y < max(temp$landSim) - scale ,,]
land.out = rbind(land.out, land2)
print(paste(r, Sys.time()))
}
# Conduct cross-classification by species and pixel
#   (generates ~7M rows, may have memory issues)
xclass.sp = c()
for (r in 1:50) {
tmp = pixelXclassBySpecies(data_dir, 'd-g2_imm-0.001', run=r, scale = 3, t_window = 186:200,
ct_threshold = 1/3)
xclass.sp = rbind(xclass.sp, tmp)
rm(tmp)
print(paste(r, Sys.time()))
}
save(xclass.out, xclass.ct, land.out, file = 'Results/Summary/EXP3/d-g2_imm-0.001/pixel_xclass_summary.Rdata')
save(xclass.sp, file = 'Results/Summary/EXP3/d-g2_imm-0.001/pixel_xclass_summary_bysp.Rdata')
library(CTSim)
that can be passed through args
# Set options and get arguments
options(stringsAsFactors=F)
args = commandArgs(trailingOnly=T)
# Set number of cores
ncores = ifelse(is.na(args[1]), 1, as.numeric(args[1]))
# Set directories
parm_dir = ifelse(is.na(args[2]), './', args[2])
results_dir = ifelse(is.na(args[3]), './Results/', args[3])
sim_dir = ifelse(is.na(args[4]), './', args[4])
# Set reporting interval
report = as.numeric(ifelse(is.na(args[5]), 0, args[5]))
# Load CTSim package
tryCatch(library(CTSim), error=function(e) library(CTSim, lib.loc=sim_dir))
# Print versions of packages being used
sessionInfo()
# Run function
run_sim_P(ncores, parm_dir, results_dir, sim_dir, report)
# Quit R without saving workspace
quit('no')
